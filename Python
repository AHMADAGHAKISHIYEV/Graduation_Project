import logging #API'ye istek gÃ¶ndermek iÃ§in gerekli kÃ¼tÃ¼phan
import sqlite3 
import requests #Hata mesajlarÄ±nÄ± kaydetmek iÃ§in kullanÄ±lÄ±r
import matplotlib.pyplot as plt
import io
import serial
import time
from datetime import datetime
from telegram import Update 
from telegram.ext import Updater, CommandHandler, CallbackContext
#VeritabanÄ± Ä°ÅŸlemleri
def vt_olustur():  #veritabanÄ±nÄ± oluÅŸturur veya var olan veritabanÄ±nÄ± aÃ§ar
    baglanti = sqlite3.connect("crypto_bot.db")  #crypto_bot.db adlÄ± veritabanÄ±na baÄŸlantÄ± oluÅŸturma
    imlec = baglanti.cursor()  #veritabanÄ±nda sorgu Ã§alÄ±ÅŸtÄ±rmak iÃ§in imleÃ§ oluÅŸturma
    imlec.execute('''CREATE TABLE IF NOT EXISTS users (user_id INTEGER PRIMARY KEY,coins TEXT)''')  #eÄŸer "users" adlÄ± tablo yoksa, oluÅŸtur
    imlec.execute('''CREATE TABLE IF NOT EXISTS investments
                  (id INTEGER PRIMARY KEY AUTOINCREMENT,
                   user_id INTEGER,
                   coin_id TEXT,
                   amount REAL,
                   initial_price REAL,
                   last_price REAL,
                   timestamp DATETIME DEFAULT CURRENT_TIMESTAMP)''')
    imlec.execute("SELECT * FROM users")
    print(imlec.fetchall())  # TÃ¼m kayÄ±tlarÄ± gÃ¶ster
    baglanti.commit()  #yapÄ±lan deÄŸiÅŸiklikleri kaydetme
    baglanti.close()  #veritabanÄ± baÄŸlantÄ±sÄ±nÄ± kapatma 
    
def kullanici_coinlerini_al(user_id):
    baglanti = sqlite3.connect("crypto_bot.db")
    imlec = baglanti.cursor()
    imlec.execute("SELECT coins FROM users WHERE user_id = ?", (user_id,))
    sonuc = imlec.fetchone()
    baglanti.commit()
    baglanti.close()
    
    if sonuc is None:
        return []
    return sonuc[0].split(',') if sonuc[0] else []
  
    
def kullanici_coinlerini_ayarla(user_id, coins):
    baglanti = sqlite3.connect("crypto_bot.db")
    imlec = baglanti.cursor()
    coinler_string = ",".join(coins)
    imlec.execute("INSERT INTO users (user_id, coins) VALUES (?, ?)", 
              (user_id, coinler_string))
    baglanti.commit()
    baglanti.close()
    
def coin_fiyati_al(coin_id): #Bu fonksiyon, verilen coin_id'nin fiyatÄ±nÄ± getirir 
    url = f"https://api.coingecko.com/api/v3/simple/price?ids={coin_id}&vs_currencies=usd"  #Coingeckodan'den fiyat verisi almak iÃ§in kullanÄ±lacak URL oluÅŸturuluyor 
    try:
        response = requests.get(url)   #Coingecko'ye HTTP GET isteÄŸi gÃ¶nderiliyor
        data = response.json() #Coingecko'den dÃ¶nen yanÄ±t JSON formatÄ±na Ã§evriliyor
        return data[coin_id]['usd']  #JSON verisinden ilgili coinin USD fiyatÄ± alÄ±nÄ±yor ve dÃ¶ndÃ¼rÃ¼lÃ¼yor
    except Exception as e:  #Coingeckoda bir hata olursa bu blok Ã§alÄ±ÅŸÄ±r
        logging.error(f"API HatasÄ±: {e}") #Hata mesajÄ±nÄ± log dosyasÄ±na kaydeder
        return None  #Hata durumunda None dÃ¶ndÃ¼rerek fonksiyonun Ã§alÄ±ÅŸmasÄ±nÄ± gÃ¼venli hale getirir  
    

# Telegram Bot KomutlarÄ±

# KullanÄ±cÄ± botu baÅŸlattÄ±ÄŸÄ±nda Ã§alÄ±ÅŸÄ±r ve botun aktif olduÄŸunu bildirir.
def baslat(update: Update, context: CallbackContext):  
    update.message.reply_text("Kripto Analiz Botuna hoÅŸ geldiniz! Bu komutlarÄ± kullanarak iÅŸlem yapa bilirsiniz .\n /coin_ekle \n /coin_sil \n /fiyat \n /coinlerim \n /yatirim_yap \n /yatirimlarim \n /yatirim_durdur \n /grafik \n /temizle")  # KullanÄ±cÄ±ya botun aktif olduÄŸu mesajÄ±nÄ± gÃ¶nderir.

# KullanÄ±cÄ±nÄ±n takip etmek istediÄŸi coinleri eklemesini saÄŸlayan fonksiyon.
def coin_ekle(update: Update, context: CallbackContext):
    try:
        user_id = update.message.from_user.id # KullanÄ±cÄ±nÄ±n kimliÄŸini alÄ±r.
        print("User ID:", user_id)
        user_input = update.message.text.split("/coin_ekle ")[1]  # KullanÄ±cÄ±nÄ±n girdiÄŸi coin listesini alÄ±r.
        yeni_coinler = [coin.strip().lower() for coin in user_input.split(",")]  # Girilen coinleri dÃ¼zenleyerek kÃ¼Ã§Ã¼k harfe Ã§evirir.
        
        mevcut_coinler = kullanici_coinlerini_al(user_id)  # KullanÄ±cÄ±nÄ±n mevcut coin listesini alÄ±r.
        guncel_coinler = list(set(mevcut_coinler + yeni_coinler))  # Mevcut ve yeni coinleri birleÅŸtirerek tekrarlarÄ± Ã¶nler.
        
        kullanici_coinlerini_ayarla(user_id, guncel_coinler)  # GÃ¼ncellenmiÅŸ coin listesini kaydeder.
        
        if user_input in mevcut_coinler:
            update.message.reply_text("Bu coin listenizde mevcut") 
        else:
            update.message.reply_text(f"BaÅŸarÄ±yla eklendi: {', '.join(yeni_coinler)}\n"
                                 f"GÃ¼ncel listeniz: {', '.join(guncel_coinler)}")
    except IndexError:
        update.message.reply_text("HatalÄ± format! LÃ¼tfen ÅŸu ÅŸekilde girin:\n"
                                  "/coin_ekle bitcoin,ethereum,solana")  # KullanÄ±cÄ± yanlÄ±ÅŸ giriÅŸ yaptÄ±ÄŸÄ±nda uyarÄ± mesajÄ± gÃ¶nderir.

# KullanÄ±cÄ±nÄ±n takip listesinden coin silmesini saÄŸlayan fonksiyon.
def coin_sil(update: Update, context: CallbackContext):
    try:
        user_id = update.message.from_user.id  # KullanÄ±cÄ±nÄ±n kimliÄŸini alÄ±r.
        user_input = update.message.text.split("/coin_sil ")[1]  # KullanÄ±cÄ±nÄ±n girdiÄŸi coin listesini alÄ±r.
        silinecek_coinler = [coin.strip().lower() for coin in user_input.split(",")]  # Girilen coinleri dÃ¼zenleyerek kÃ¼Ã§Ã¼k harfe Ã§evirir.

        mevcut_coinler = kullanici_coinlerini_al(user_id)  # KullanÄ±cÄ±nÄ±n mevcut coin listesini alÄ±r.
        
        # Silinecek coinleri mevcut listeden Ã§Ä±kararak gÃ¼ncellenmiÅŸ listeyi oluÅŸturur.
        guncel_coinler = [coin for coin in mevcut_coinler if coin not in silinecek_coinler]
        
        # EÄŸer hiÃ§bir coin silinmemiÅŸse, kullanÄ±cÄ±yÄ± bilgilendirir.
        if len(guncel_coinler) == len(mevcut_coinler):
            bulunamayanlar = [coin for coin in silinecek_coinler if coin not in mevcut_coinler]  # KullanÄ±cÄ±nÄ±n listesinde olmayan coinleri belirler.
            update.message.reply_text(f"Åu coinler listenizde yok: {', '.join(bulunamayanlar)}")  # KullanÄ±cÄ±yÄ± bilgilendirir.
            return

        kullanici_coinlerini_ayarla(user_id, guncel_coinler)  # GÃ¼ncellenmiÅŸ coin listesini kaydeder.
        update.message.reply_text(f"BaÅŸarÄ±yla silindi: {', '.join(silinecek_coinler)}\n"
                                 f"GÃ¼ncel listeniz: {', '.join(guncel_coinler)}")  # KullanÄ±cÄ±ya gÃ¼ncellenmiÅŸ listesini gÃ¶sterir.
    
    except IndexError:
        update.message.reply_text("HatalÄ± format! LÃ¼tfen ÅŸu ÅŸekilde girin:\n"
                                  "/coin_sil bitcoin,ethereum")  # KullanÄ±cÄ± yanlÄ±ÅŸ giriÅŸ yaptÄ±ÄŸÄ±nda uyarÄ± mesajÄ± gÃ¶nderir.

# KullanÄ±cÄ±nÄ±n eklediÄŸi tÃ¼m coinleri listeleyen fonksiyon.
def coinlerim(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id  # KullanÄ±cÄ±nÄ±n kimliÄŸini alÄ±r.
    coinler = kullanici_coinlerini_al(user_id)  # KullanÄ±cÄ±nÄ±n kayÄ±tlÄ± coin listesini alÄ±r.
    
    if coinler:
        update.message.reply_text(f" KayÄ±tlÄ± Coinleriniz:\n{', '.join(coinler)}")  # KullanÄ±cÄ±nÄ±n coin listesini gÃ¶sterir.
    else:
        update.message.reply_text("â„¹ HenÃ¼z kayÄ±tlÄ± coininiz yok. /coin_ekle ile ekleyin!")  # KullanÄ±cÄ±nÄ±n coin listesi boÅŸsa bilgilendirir.

# Botun ana fonksiyonu, Telegram botunu baÅŸlatÄ±r ve komutlarÄ± tanÄ±mlar.
def fiyat_bilgisi(update: Update, context: CallbackContext):
    try:
        # KullanÄ±cÄ±nÄ±n girdiÄŸi coin listesini alma
        user_input = update.message.text.split("/fiyat ")[1].strip()
        coin_listesi = [coin.strip().lower() for coin in user_input.split(",")]
        
        # Fiyat bilgilerini toplama
        mesaj = " AnlÄ±k Fiyat Bilgileri:\n\n"
        for coin in coin_listesi:
            fiyat = coin_fiyati_al(coin)
            if fiyat is not None:
                mesaj += f"â€¢ {coin.upper()}: ${fiyat:.10f}\n"
            else:
                mesaj += f"â€¢ {coin.upper()}: Veri alÄ±namadÄ±\n"
        
        update.message.reply_text(mesaj)
    
    except IndexError:
        update.message.reply_text(" LÃ¼tfen coinleri virgÃ¼lle ayÄ±rarak belirtin!\nÃ–rnek kullanÄ±m: /fiyat bitcoin,ethereum")
        
def yatirim_yap(update: Update, context: CallbackContext):
    try:
        # KullanÄ±cÄ± bilgilerini ve komut parametrelerini al
        user_id = update.message.from_user.id
        args = context.args
        
        # Eksik parametre kontrolÃ¼ (en az 2 parametre olmalÄ±)
        if len(args) < 2:
            raise ValueError  # Hata fÄ±rlat
        
        # Coin adÄ±nÄ± kÃ¼Ã§Ã¼k harfe Ã§evir
        coin_id = args[0].lower()
        # YatÄ±rÄ±m miktarÄ±nÄ± ondalÄ±klÄ± sayÄ±ya Ã§evir
        amount = float(args[1])
        
        # Coin'in anlÄ±k fiyatÄ±nÄ± API'den al
        current_price = coin_fiyati_al(coin_id)
        if not current_price:  # Fiyat alÄ±namazsa
            update.message.reply_text("GeÃ§ersiz coin veya fiyat bilgisi alÄ±namadÄ±!")
            return  # Fonksiyonu sonlandÄ±r

        # VeritabanÄ± baÄŸlantÄ±sÄ±nÄ± aÃ§
        baglanti = sqlite3.connect("crypto_bot.db")
        imlec = baglanti.cursor()
        
        # Yeni yatÄ±rÄ±mÄ± veritabanÄ±na ekle
        imlec.execute('''INSERT INTO investments 
                      (user_id, coin_id, amount, initial_price, last_price)
                      VALUES (?, ?, ?, ?, ?)''',
                   (user_id, coin_id, amount, current_price, current_price))
        
        # Eklenen yatÄ±rÄ±mÄ±n ID'sini al
        investment_id = imlec.lastrowid
        baglanti.commit()  # DeÄŸiÅŸiklikleri kaydet
        baglanti.close()  # BaÄŸlantÄ±yÄ± kapat

        # Her 30 saniyede bir gÃ¼ncelleme gÃ¶revi planla
        context.job_queue.run_repeating(
            yatirim_guncelle, 
            interval=30,  # 30 saniye aralÄ±k
            first=0,  # Ä°lk Ã§alÄ±ÅŸma hemen olsun
            context={  # GÃ¶rev baÄŸlam verileri
                'user_id': user_id,
                'investment_id': investment_id,
                'coin_id': coin_id,
                'amount': amount
            }
        )
        
        # KullanÄ±cÄ±ya onay mesajÄ± gÃ¶nder
        update.message.reply_text(
            f"âœ… {amount} {coin_id.upper()} yatÄ±rÄ±mÄ± kaydedildi!\n"
            f"BaÅŸlangÄ±Ã§ FiyatÄ±: ${current_price:.4f}"
        )
        
    except (ValueError, IndexError):
        # HatalÄ± giriÅŸ formatÄ± durumunda bilgilendirme
        update.message.reply_text("HatalÄ± format! DoÄŸru kullanÄ±m:\n/yatirim_yap <coin> <miktar>\nÃ–rnek: /yatirim_yap bitcoin 0.5")
def yatirim_guncelle(context: CallbackContext):
    # ZamanlanmÄ±ÅŸ gÃ¶rev bilgilerini al
    job = context.job
    user_id = job.context['user_id']
    investment_id = job.context['investment_id']
    coin_id = job.context['coin_id']
    amount = job.context['amount']
    
    # Coin'in gÃ¼ncel fiyatÄ±nÄ± al
    current_price = coin_fiyati_al(coin_id)
    if not current_price:  # Fiyat alÄ±namazsa
        return  # Fonksiyonu sonlandÄ±r

    # VeritabanÄ± baÄŸlantÄ±sÄ±nÄ± aÃ§
    baglanti = sqlite3.connect("crypto_bot.db")
    imlec = baglanti.cursor()
    
    # Son kayÄ±tlÄ± fiyatÄ± veritabanÄ±ndan Ã§ek
    imlec.execute("SELECT last_price FROM investments WHERE id=?", (investment_id,))
    last_price = imlec.fetchone()[0]  # Ä°lk sonucun ilk deÄŸerini al
    
    # YÃ¼zdelik deÄŸiÅŸimi hesapla
    change_pct = ((current_price - last_price) / last_price) * 100
    # DeÄŸiÅŸim yÃ¶nÃ¼ne gÃ¶re emoji seÃ§
    change_emoji = "ğŸŸ¢ â–²" if change_pct >= 0 else "ğŸ”´ â–¼"
    
    # DeÄŸer hesaplamalarÄ± yap
    current_value = amount * current_price  # GÃ¼ncel toplam deÄŸer
    value_change = current_value - (amount * last_price)  # DeÄŸiÅŸim miktarÄ±
    
    # MesajÄ± formatla
    message = (
        f"{coin_id.upper()} YatÄ±rÄ±m GÃ¼ncellemesi:\n"
        f"â”Œ Mevcut Fiyat: ${current_price:.4f}\n"
        f"â”œ Son 10 saniye: {change_emoji} {abs(change_pct):.2f}%\n"
        f"â”œ Toplam DeÄŸer: ${current_value:.2f}\n"
        f"â”” DeÄŸiÅŸim: {'+' if value_change >=0 else ''}{value_change:.2f}$"
    )
    
    # VeritabanÄ±ndaki son fiyatÄ± gÃ¼ncelle
    imlec.execute("UPDATE investments SET last_price=? WHERE id=?", (current_price, investment_id))
    baglanti.commit()  # DeÄŸiÅŸiklikleri kaydet
    baglanti.close()  # BaÄŸlantÄ±yÄ± kapat
    
    # KullanÄ±cÄ±ya mesaj gÃ¶nder
    context.bot.send_message(chat_id=user_id, text=message)
    
    try:
        # Arduino iletiÅŸimi iÃ§in seri portu aÃ§
        print(f"Arduino'ya gÃ¶nderiliyor: {'G' if change_pct >=0 else 'R'}")
        arduino = serial.Serial('COM3', 9600)  # Port ve baud rate ayarÄ±
        time.sleep(2)  # BaÄŸlantÄ± iÃ§in bekle
        arduino.write(b'G' if change_pct >=0 else b'R')  # Duruma gÃ¶re sinyal gÃ¶nder
        arduino.close()  # BaÄŸlan       tÄ±yÄ± kapat
    except Exception as e:
        print("Arduino HatasÄ±:", str(e))  # Hata mesajÄ±nÄ± konsola yaz
    
def aktif_yatirimlari_al(user_id):
    # VeritabanÄ± baÄŸlantÄ±sÄ±nÄ± aÃ§
    baglanti = sqlite3.connect("crypto_bot.db")
    imlec = baglanti.cursor()
    
    # KullanÄ±cÄ±nÄ±n tÃ¼m aktif yatÄ±rÄ±mlarÄ±nÄ± sorgula
    imlec.execute("SELECT id, coin_id, amount FROM investments WHERE user_id=?", (user_id,))
    yatirimlar = imlec.fetchall()  # TÃ¼m sonuÃ§larÄ± al
    
    baglanti.close()  # BaÄŸlantÄ±yÄ± kapat
    
    return yatirimlar  # (id, coin_id, amount) tuple listesi dÃ¶ndÃ¼r

def yatirimlarim(update: Update, context: CallbackContext):
    # Komutu gÃ¶nderen kullanÄ±cÄ±nÄ±n ID'sini al
    user_id = update.message.from_user.id
    
    # VeritabanÄ±ndan kullanÄ±cÄ±nÄ±n aktif yatÄ±rÄ±mlarÄ±nÄ± Ã§ek
    yatirimlar = aktif_yatirimlari_al(user_id)
    
    # EÄŸer yatÄ±rÄ±m yoksa bilgilendir ve Ã§Ä±k
    if not yatirimlar:
        update.message.reply_text("ğŸ“­ Aktif yatÄ±rÄ±mÄ±nÄ±z bulunmamaktadÄ±r.")
        return  # Fonksiyonu sonlandÄ±r
        
    # MesajÄ± oluÅŸturmaya baÅŸla
    mesaj = "ğŸ” Aktif YatÄ±rÄ±mlarÄ±nÄ±z:\n\n"
    
    # Her yatÄ±rÄ±mÄ± mesaja ekle
    for yatirim in yatirimlar:
        # Format: ID | COIN | Miktar
        mesaj += f"ID: {yatirim[0]} | {yatirim[1].upper()} | Miktar: {yatirim[2]}\n"
    
    # Durdurma talimatÄ±nÄ± ekle
    mesaj += "\nğŸš« Durdurmak iÃ§in: /yatirim_durdur <ID>"
    
    # MesajÄ± kullanÄ±cÄ±ya gÃ¶nder
    update.message.reply_text(mesaj)

def yatirim_durdur(update: Update, context: CallbackContext):
    try:
        # KullanÄ±cÄ± ve girilen ID'yi al
        user_id = update.message.from_user.id
        yatirim_id = int(context.args[0])  # ID'yi sayÄ±ya Ã§evir
        
        # TÃ¼m aktif iÅŸleri kontrol et
        for job in context.job_queue.jobs():
            # Ä°ÅŸin baÄŸlamÄ±ndaki bilgileri kontrol et
            if (
                job.context.get('investment_id') == yatirim_id 
                and job.context['user_id'] == user_id
            ):
                # EÅŸleÅŸen iÅŸi kuyruktan kaldÄ±r
                job.schedule_removal()
                update.message.reply_text(f"âœ… ID: {yatirim_id} bildirimler durduruldu.")
                return  # Ä°ÅŸlem tamamlandÄ±, fonksiyondan Ã§Ä±k
        
        # EÅŸleÅŸme bulunamazsa uyar
        update.message.reply_text("âŒ GeÃ§ersiz ID veya zaten durduruldu.")
        
    except (IndexError, ValueError):
        # HatalÄ± format durumunda kullanÄ±cÄ±yÄ± bilgilendir
        update.message.reply_text(
            "âš ï¸ HatalÄ± format! DoÄŸru kullanÄ±m:\n"
            "/yatirim_durdur <ID>\n"
            "Ã–rnek: /yatirim_durdur 5"
        )
        
def fiyat_grafigi(update: Update, context: CallbackContext):
    try:
        # KullanÄ±cÄ±nÄ±n girdiÄŸi coin adÄ±nÄ± al ve temizle (Ã¶rnek: "/grafik bitcoin 30")
        coin_id = context.args[0].lower().strip()
        
        # KullanÄ±cÄ± gÃ¼n sayÄ±sÄ± belirtmemiÅŸse varsayÄ±lan 7 gÃ¼n kullan
        gun_sayisi = int(context.args[1]) if len(context.args) > 1 else 7

        # CoinGecko API'den tarihsel verileri Ã§ek
        url = f"https://api.coingecko.com/api/v3/coins/{coin_id}/market_chart?vs_currency=usd&days={gun_sayisi}"
        response = requests.get(url)  # API'ye GET isteÄŸi gÃ¶nder
        data = response.json()  # Gelen JSON verisini Ã§evir

        # API'den gelen fiyat ve zaman verilerini iÅŸle:
        fiyatlar = [entry[1] for entry in data['prices']]  # Her zaman noktasÄ±ndaki fiyatÄ± al
        zamanlar = [datetime.fromtimestamp(entry[0]/1000) for entry in data['prices']]  # zaman damgasÄ±nÄ± datetime'a Ã§evir

        # Matplotlib ile grafik oluÅŸtur:
        plt.figure(figsize=(10, 6))  # 10x6 inÃ§ boyutunda grafik
        plt.plot(zamanlar, fiyatlar, linewidth=2, color='#4B8BBE')  # Mavi Ã§izgi ile fiyatlarÄ± Ã§iz
        plt.title(f"{coin_id.upper()} Fiyat GrafiÄŸi ({gun_sayisi} GÃ¼n)", fontsize=14, pad=20)  # BaÅŸlÄ±k ekle
        plt.xlabel("Tarih", fontsize=12)  # X ekseni etiketi
        plt.ylabel("Fiyat (USD)", fontsize=12)  # Y ekseni etiketi
        plt.grid(True, alpha=0.3)  # %30 opaklÄ±kta grid Ã§izgileri
        plt.xticks(rotation=45)  # Tarih etiketlerini 45 derece dÃ¶ndÃ¼r
        plt.tight_layout()  # Grafik elementlerini sÄ±kÄ± yerleÅŸtir

        # GrafiÄŸi bellekte sakla:
        buf = io.BytesIO()  # Bellek Ã¼zerinde binary dosya oluÅŸtur
        plt.savefig(buf, format='png', dpi=150)  # 150 DPI Ã§Ã¶zÃ¼nÃ¼rlÃ¼kte PNG olarak kaydet
        buf.seek(0)  # Dosya imlecini baÅŸa al
        plt.close()  # Grafik penceresini kapat

        # KullanÄ±cÄ±ya grafiÄŸi fotoÄŸraf olarak gÃ¶nder:
        update.message.reply_photo(
            photo=buf,  # Bellekteki gÃ¶rsel dosyasÄ±
            caption=f" {coin_id.upper()} {gun_sayisi} GÃ¼nlÃ¼k Fiyat GrafiÄŸi",  # AÃ§Ä±klama metni
            parse_mode='Markdown'  # Metin formatlama iÃ§in Markdown kullan
        )
        
    except IndexError:
        # KullanÄ±cÄ± eksik parametre girmiÅŸse hata mesajÄ± gÃ¶nder
        update.message.reply_text(" HatalÄ± format! DoÄŸru kullanÄ±m:\n/grafik <coin_adi> <gÃ¼n_sayÄ±sÄ±>")
    except Exception as e:
        # DiÄŸer tÃ¼m hatalarÄ± logla ve kullanÄ±cÄ±yÄ± bilgilendir
        logging.error(f"Grafik HatasÄ±: {e}")
        update.message.reply_text(" Grafik oluÅŸturulurken bir hata oluÅŸtu")
def yatirimlarimi_temizle(update: Update, context: CallbackContext):
    # Komutu gÃ¶nderen kullanÄ±cÄ±nÄ±n ID'sini al
    user_id = update.message.from_user.id
    
    try:
        # VeritabanÄ± baÄŸlantÄ±sÄ±nÄ± aÃ§
        conn = sqlite3.connect('crypto_bot.db')
        c = conn.cursor()
        
        # 1. ADIM: Bu kullanÄ±cÄ±nÄ±n tÃ¼m yatÄ±rÄ±m kayÄ±tlarÄ±nÄ± sil
        c.execute("DELETE FROM investments WHERE user_id=?", (user_id,))
        
        # 2. ADIM: Yeni ID'leri dÃ¼zenle (SQLite Ã§Ã¶zÃ¼mÃ¼)
        # TÃ¼m tablodaki en yÃ¼ksek ID'yi bul
        c.execute("SELECT MAX(id) FROM investments")
        max_id = c.fetchone()[0] or 0  # EÄŸer hiÃ§ kayÄ±t yoksa 0 kullan
        
        # Bir sonraki ID'yi mevcut maksimum +1 olarak ayarla
        new_sequence = max_id + 1
        # SQLite'Ä±n otomatik artan ID sistemini gÃ¼ncelle
        c.execute("UPDATE sqlite_sequence SET seq=? WHERE name='investments'", (new_sequence,))
        
        # DeÄŸiÅŸiklikleri kaydet ve baÄŸlantÄ±yÄ± kapat
        conn.commit()
        conn.close()
        
        # KullanÄ±cÄ±ya baÅŸarÄ± mesajÄ± gÃ¶nder
        update.message.reply_text(" YatÄ±rÄ±m geÃ§miÅŸiniz temizlendi! Yeni ID'leriniz Ã¶zel sÄ±ralamayla baÅŸlayacak.")
        
    except Exception as e:
        # Herhangi bir hata durumunda kullanÄ±cÄ±yÄ± bilgilendir
        update.message.reply_text(f"â›” Hata: {str(e)}") 


def main():
    vt_olustur()  # VeritabanÄ±nÄ± oluÅŸturur veya mevcutsa aÃ§ar.
    
    updater = Updater(token="", use_context=True)  # Telegram botu iÃ§in Updater nesnesi oluÅŸturur.
    dispatcher = updater.dispatcher  # KomutlarÄ± yÃ¶netmek iÃ§in Dispatcher nesnesi oluÅŸturur.
    dispatcher.add_handler(CommandHandler("baslat", baslat))  # /baslat komutunu baÄŸlar.
    dispatcher.add_handler(CommandHandler("coin_ekle", coin_ekle))  # /coin_ekle komutunu baÄŸlar.
    dispatcher.add_handler(CommandHandler("coin_sil", coin_sil)) # /coin_sil
    dispatcher.add_handler(CommandHandler("coinlerim", coinlerim))  # /coinlerim komutunu baÄŸlar.
    dispatcher.add_handler(CommandHandler("fiyat", fiyat_bilgisi))
    dispatcher.add_handler(CommandHandler("yatirim_yap", yatirim_yap, pass_args=True))
    dispatcher.add_handler(CommandHandler("yatirimlarim", yatirimlarim))
    dispatcher.add_handler(CommandHandler("yatirim_durdur", yatirim_durdur, pass_args=True))
    dispatcher.add_handler(CommandHandler("grafik", fiyat_grafigi, pass_args=True))
    dispatcher.add_handler(CommandHandler("temizle", yatirimlarimi_temizle))
    updater.start_polling()  # Botu baÅŸlatÄ±r ve gelen mesajlarÄ± dinlemeye baÅŸlar.
    updater.idle()  # Botun Ã§alÄ±ÅŸmaya devam etmesini saÄŸlar.
    

if __name__ == "__main__":
    main()
